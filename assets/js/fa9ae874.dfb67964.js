"use strict";(self.webpackChunkq_01_docs=self.webpackChunkq_01_docs||[]).push([[1756],{4976:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>o});var r=t(7624),s=t(2172);const i={title:"Outbox Pattern",sidebar_label:"Outbox Pattern",sidebar_position:9,description:"Event sourcing with write-ahead log and RabbitMQ"},a="Outbox Pattern",d={id:"products/map.q01.io/core-api-platform-v4/write-patterns/outbox-pattern",title:"Outbox Pattern",description:"Event sourcing with write-ahead log and RabbitMQ",source:"@site/docs/products/map.q01.io/core-api-platform-v4/04-write-patterns/outbox-pattern.md",sourceDirName:"products/map.q01.io/core-api-platform-v4/04-write-patterns",slug:"/products/map.q01.io/core-api-platform-v4/write-patterns/outbox-pattern",permalink:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/outbox-pattern",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Outbox Pattern",sidebar_label:"Outbox Pattern",sidebar_position:9,description:"Event sourcing with write-ahead log and RabbitMQ"},sidebar:"mapSidebar",previous:{title:"Cascade Operations",permalink:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/cascade-operations"},next:{title:"Counter Management",permalink:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/counter-management"}},c={},o=[{value:"Overview",id:"overview",level:2},{value:"Outbox Table",id:"outbox-table",level:2},{value:"Schema",id:"schema",level:3},{value:"Event Creation",id:"event-creation",level:2},{value:"Write Operation with Outbox",id:"write-operation-with-outbox",level:3},{value:"Event Types",id:"event-types",level:3},{value:"Event Structure",id:"event-structure",level:2},{value:"Payload Format",id:"payload-format",level:3},{value:"Event Publishing",id:"event-publishing",level:2},{value:"Background Publisher Process",id:"background-publisher-process",level:3},{value:"RabbitMQ Exchange",id:"rabbitmq-exchange",level:3},{value:"Event Subscribers",id:"event-subscribers",level:2},{value:"Search Indexer Example",id:"search-indexer-example",level:3},{value:"Cache Invalidator Example",id:"cache-invalidator-example",level:3},{value:"Guarantees and Properties",id:"guarantees-and-properties",level:2},{value:"At-Least-Once Delivery",id:"at-least-once-delivery",level:3},{value:"Event Ordering",id:"event-ordering",level:3},{value:"Idempotency",id:"idempotency",level:3},{value:"Monitoring and Operations",id:"monitoring-and-operations",level:2},{value:"Health Checks",id:"health-checks",level:3},{value:"Retry Failed Events",id:"retry-failed-events",level:3},{value:"Cleanup Old Events",id:"cleanup-old-events",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 DO:",id:"-do",level:3},{value:"\u274c DON&#39;T:",id:"-dont",level:3},{value:"Summary",id:"summary",level:2},{value:"Related Concepts",id:"related-concepts",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"outbox-pattern",children:"Outbox Pattern"}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Outbox Pattern"})," ensures reliable event publishing by writing events to a database table (OUTBOX) within the same transaction as the main operation. A background process then publishes events to RabbitMQ, guaranteeing at-least-once delivery."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 At-least-once delivery guarantee"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Events never lost (transactional persistence)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Eventual consistency across microservices"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Event replay for debugging"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Complete audit trail"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Architecture:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Write Operation (POST/PUT/PATCH/DELETE)\n    \u2193\n1. Update TB_ANAG_{DIM}00 (data table)\n2. Insert OUTBOX (event table)\n3. COMMIT transaction (atomic)\n    \u2193\nBackground Publisher Process\n    \u2193\nPublish to RabbitMQ Fanout Exchange\n    \u2193\nSubscribers (search-indexer, cache-invalidator, analytics, etc.)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"outbox-table",children:"Outbox Table"}),"\n",(0,r.jsx)(n.h3,{id:"schema",children:"Schema"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"OUTBOX table stores all events:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE OUTBOX (\n    OUTBOX_ID VARCHAR(36) PRIMARY KEY,  -- UUID\n    EVENT_TYPE VARCHAR(100) NOT NULL,   -- ProductCreated, OrderUpdated, etc.\n    AGGREGATE_ID VARCHAR(36) NOT NULL,  -- Record ID (PRD_ID, ORD_ID, etc.)\n    AGGREGATE_TYPE VARCHAR(10) NOT NULL, -- Dimension (PRD, ORD, etc.)\n    OPERATION VARCHAR(10) NOT NULL,      -- POST, PUT, PATCH, DELETE\n    PAYLOAD TEXT NOT NULL,               -- JSON serialized data\n    METADATA TEXT,                       -- Session context (source, centro_dett, etc.)\n    USER VARCHAR(255),                   -- Who performed the operation\n    CREATED_AT VARCHAR(14) NOT NULL,     -- Event timestamp\n    PUBLISHED_AT VARCHAR(14),            -- When published to RabbitMQ\n    STATUS VARCHAR(20) DEFAULT 'PENDING', -- PENDING, PUBLISHED, FAILED\n    RETRY_COUNT INT DEFAULT 0,           -- Number of publish attempts\n    ERROR_MESSAGE TEXT                   -- Last error (if failed)\n);\n\nCREATE INDEX idx_outbox_status ON OUTBOX(STATUS);\nCREATE INDEX idx_outbox_created_at ON OUTBOX(CREATED_AT);\nCREATE INDEX idx_outbox_aggregate ON OUTBOX(AGGREGATE_TYPE, AGGREGATE_ID);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"event-creation",children:"Event Creation"}),"\n",(0,r.jsx)(n.h3,{id:"write-operation-with-outbox",children:"Write Operation with Outbox"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Every write operation inserts event:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// CoreWrite DataStore.php\npublic function insert(string $dimension, array $data): array {\n    $this->pdo->beginTransaction();\n\n    try {\n        // 1. Insert main record\n        $recordId = $this->insertMainRecord($dimension, $data);\n\n        // 2. Execute cascades\n        $this->executeCascades($dimension, $recordId, $data);\n\n        // 3. Insert outbox event (same transaction!)\n        $eventId = Uuid::uuid4();\n        $event = [\n            'OUTBOX_ID' => $eventId,\n            'EVENT_TYPE' => $this->getEventType($dimension, 'POST'),  // \"ProductCreated\"\n            'AGGREGATE_ID' => $recordId,\n            'AGGREGATE_TYPE' => $dimension,\n            'OPERATION' => 'POST',\n            'PAYLOAD' => json_encode($data),\n            'METADATA' => json_encode($this->getSessionContext()),\n            'USER' => $this->getCurrentUser(),\n            'CREATED_AT' => date('YmdHis'),\n            'STATUS' => 'PENDING'\n        ];\n\n        $this->pdo->execute(\"INSERT INTO OUTBOX (...) VALUES (...)\", $event);\n\n        // 4. Commit (data + event persisted atomically)\n        $this->pdo->commit();\n\n        return ['id' => $recordId, 'status' => 'success'];\n    } catch (\\Exception $e) {\n        $this->pdo->rollBack();  // Both data AND event rolled back\n        throw $e;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-types",children:"Event Types"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event type conventions:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"Event Type"}),(0,r.jsx)(n.th,{children:"Example"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{Dimension}Created"})}),(0,r.jsx)(n.td,{children:"ProductCreated, OrderCreated"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"PUT/PATCH"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{Dimension}Updated"})}),(0,r.jsx)(n.td,{children:"ProductUpdated, OrderUpdated"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DELETE (soft)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{Dimension}Deleted"})}),(0,r.jsx)(n.td,{children:"ProductDeleted, OrderDeleted"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DELETE (force)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{Dimension}ForceDeleted"})}),(0,r.jsx)(n.td,{children:"ProductForceDeleted"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"event-structure",children:"Event Structure"}),"\n",(0,r.jsx)(n.h3,{id:"payload-format",children:"Payload Format"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ProductCreated event:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "OUTBOX_ID": "550e8400-e29b-41d4-a716-446655440000",\n  "EVENT_TYPE": "ProductCreated",\n  "AGGREGATE_ID": "123",\n  "AGGREGATE_TYPE": "PRD",\n  "OPERATION": "POST",\n  "PAYLOAD": {\n    "PRD_ID": "123",\n    "XPRD01": "Widget Pro",\n    "XPRD02": 99.99,\n    "XPRD03": "PRD-2025-001",\n    "XPRD05": "cat_electronics",\n    "XPRD06": true,\n    "TREC": "N"\n  },\n  "METADATA": {\n    "source": "productManagement",\n    "centro_dett": "admin",\n    "microservice": "adminApp",\n    "peso": "1",\n    "ambiente": "production",\n    "lingua": "en"\n  },\n  "USER": "user@example.com",\n  "CREATED_AT": "20251219160000",\n  "STATUS": "PENDING"\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ProductUpdated event:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "OUTBOX_ID": "660f9511-f3a-42e5-b827-557766550001",\n  "EVENT_TYPE": "ProductUpdated",\n  "AGGREGATE_ID": "123",\n  "AGGREGATE_TYPE": "PRD",\n  "OPERATION": "PATCH",\n  "PAYLOAD": {\n    "PRD_ID": "123",\n    "XPRD02": 89.99,  // Changed fields only\n    "TREC": "M"\n  },\n  "PREVIOUS_PAYLOAD": {\n    "XPRD02": 99.99  // Previous values (optional)\n  },\n  "METADATA": {\n    "source": "productManagement",\n    "centro_dett": "admin"\n  },\n  "USER": "admin@example.com",\n  "CREATED_AT": "20251219170000",\n  "STATUS": "PENDING"\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"event-publishing",children:"Event Publishing"}),"\n",(0,r.jsx)(n.h3,{id:"background-publisher-process",children:"Background Publisher Process"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Polls OUTBOX table and publishes to RabbitMQ:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// Background publisher (runs every second)\nclass OutboxPublisher {\n    private $pdo;\n    private $rabbitMQ;\n\n    public function publishPendingEvents(int $batchSize = 100): void {\n        // 1. Fetch pending events\n        $events = $this->pdo->query(\n            \"SELECT * FROM OUTBOX\n             WHERE STATUS = 'PENDING'\n             ORDER BY CREATED_AT ASC\n             LIMIT :batch_size\",\n            ['batch_size' => $batchSize]\n        )->fetchAll();\n\n        foreach ($events as $event) {\n            try {\n                // 2. Publish to RabbitMQ\n                $this->rabbitMQ->publish(\n                    exchange: 'corewrite.fanout',\n                    routingKey: $this->getRoutingKey($event),\n                    message: json_encode($event),\n                    properties: [\n                        'content_type' => 'application/json',\n                        'delivery_mode' => 2  // Persistent\n                    ]\n                );\n\n                // 3. Mark as published\n                $this->pdo->execute(\n                    \"UPDATE OUTBOX\n                     SET STATUS = 'PUBLISHED',\n                         PUBLISHED_AT = :published_at\n                     WHERE OUTBOX_ID = :id\",\n                    [\n                        'published_at' => date('YmdHis'),\n                        'id' => $event['OUTBOX_ID']\n                    ]\n                );\n\n                echo \"Published event: {$event['EVENT_TYPE']} (ID: {$event['OUTBOX_ID']})\\n\";\n            } catch (\\Exception $e) {\n                // 4. Mark as failed, retry later\n                $this->pdo->execute(\n                    \"UPDATE OUTBOX\n                     SET STATUS = 'FAILED',\n                         ERROR_MESSAGE = :error,\n                         RETRY_COUNT = RETRY_COUNT + 1\n                     WHERE OUTBOX_ID = :id\",\n                    [\n                        'error' => $e->getMessage(),\n                        'id' => $event['OUTBOX_ID']\n                    ]\n                );\n\n                echo \"Failed to publish event: {$event['OUTBOX_ID']} - {$e->getMessage()}\\n\";\n            }\n        }\n    }\n\n    private function getRoutingKey(array $event): string {\n        // Routing key format: {dimension}.{operation}\n        $dimension = strtolower($event['AGGREGATE_TYPE']);\n        $operation = strtolower($event['OPERATION']);\n        return \"{$dimension}.{$operation}\";\n    }\n}\n\n// Run publisher continuously\nwhile (true) {\n    $publisher = new OutboxPublisher($pdo, $rabbitMQ);\n    $publisher->publishPendingEvents(100);\n    sleep(1);  // Poll every second\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rabbitmq-exchange",children:"RabbitMQ Exchange"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fanout exchange broadcasts to all subscribers:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Exchange: corewrite.fanout\nType: fanout\nDurable: true\nAuto-delete: false\n\nSubscribers:\n\u251c\u2500\u2500 search-indexer (updates Elasticsearch)\n\u251c\u2500\u2500 cache-invalidator (clears Redis cache)\n\u251c\u2500\u2500 analytics-writer (writes to analytics DB)\n\u251c\u2500\u2500 audit-logger (logs to audit trail)\n\u2514\u2500\u2500 notification-sender (sends email/push notifications)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fanout benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All subscribers receive events"}),"\n",(0,r.jsx)(n.li,{children:"Adding subscribers doesn't affect publisher"}),"\n",(0,r.jsx)(n.li,{children:"Subscribers process events independently"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"event-subscribers",children:"Event Subscribers"}),"\n",(0,r.jsx)(n.h3,{id:"search-indexer-example",children:"Search Indexer Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// search-indexer subscriber (Node.js)\nconst amqp = require('amqplib');\n\nasync function startSearchIndexer() {\n  const connection = await amqp.connect('amqp://rabbitmq:5672');\n  const channel = await connection.createChannel();\n\n  // Bind to fanout exchange\n  const exchange = 'corewrite.fanout';\n  await channel.assertExchange(exchange, 'fanout', { durable: true });\n\n  // Create queue for this subscriber\n  const queue = await channel.assertQueue('search-indexer', {\n    durable: true,\n    autoDelete: false\n  });\n\n  // Bind queue to exchange\n  await channel.bindQueue(queue.queue, exchange, '');\n\n  // Consume events\n  channel.consume(queue.queue, async (msg) => {\n    if (msg) {\n      const event = JSON.parse(msg.content.toString());\n\n      try {\n        await handleEvent(event);\n        channel.ack(msg);  // Acknowledge successful processing\n      } catch (error) {\n        console.error('Failed to process event:', error);\n        channel.nack(msg, false, true);  // Requeue for retry\n      }\n    }\n  });\n\n  console.log('Search indexer started. Waiting for events...');\n}\n\nasync function handleEvent(event) {\n  switch (event.EVENT_TYPE) {\n    case 'ProductCreated':\n      await elasticsearch.index({\n        index: 'products',\n        id: event.AGGREGATE_ID,\n        body: event.PAYLOAD\n      });\n      console.log(`Indexed product: ${event.AGGREGATE_ID}`);\n      break;\n\n    case 'ProductUpdated':\n      await elasticsearch.update({\n        index: 'products',\n        id: event.AGGREGATE_ID,\n        body: { doc: event.PAYLOAD }\n      });\n      console.log(`Updated product index: ${event.AGGREGATE_ID}`);\n      break;\n\n    case 'ProductDeleted':\n      await elasticsearch.delete({\n        index: 'products',\n        id: event.AGGREGATE_ID\n      });\n      console.log(`Removed product from index: ${event.AGGREGATE_ID}`);\n      break;\n  }\n}\n\nstartSearchIndexer();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cache-invalidator-example",children:"Cache Invalidator Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// cache-invalidator subscriber\nasync function handleEvent(event) {\n  const cacheKeys = getCacheKeys(event);\n\n  for (const key of cacheKeys) {\n    await redis.del(key);\n    console.log(`Invalidated cache: ${key}`);\n  }\n}\n\nfunction getCacheKeys(event) {\n  const keys = [];\n  const id = event.AGGREGATE_ID;\n  const dim = event.AGGREGATE_TYPE;\n\n  // Invalidate record cache\n  keys.push(`${dim}:${id}`);\n\n  // Invalidate list caches\n  keys.push(`${dim}:list:*`);\n\n  // Dimension-specific invalidation\n  if (dim === 'PRD' && event.PAYLOAD.XPRD05) {\n    // Invalidate category cache\n    keys.push(`CAT:${event.PAYLOAD.XPRD05}:products`);\n  }\n\n  return keys;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"guarantees-and-properties",children:"Guarantees and Properties"}),"\n",(0,r.jsx)(n.h3,{id:"at-least-once-delivery",children:"At-Least-Once Delivery"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event will be delivered at least once to each subscriber:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Write Operation Success\n    \u2193\nEvent in OUTBOX (PENDING)\n    \u2193\nPublisher attempts delivery\n    \u251c\u2500 Success \u2192 STATUS='PUBLISHED'\n    \u2514\u2500 Failure \u2192 STATUS='FAILED', RETRY_COUNT++\n        \u2193\n    Retry with exponential backoff\n        \u2193\n    Eventually succeeds or manual intervention\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Subscribers must be idempotent:"})," Same event processed multiple times should have same result."]}),"\n",(0,r.jsx)(n.h3,{id:"event-ordering",children:"Event Ordering"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Events ordered by CREATED_AT within same aggregate:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM OUTBOX\nWHERE AGGREGATE_TYPE = 'PRD' AND AGGREGATE_ID = '123'\nORDER BY CREATED_AT ASC;\n\n-- Result:\n-- 1. ProductCreated   (20251219160000)\n-- 2. ProductUpdated   (20251219170000)\n-- 3. ProductDeleted   (20251219180000)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Across aggregates:"})," No ordering guarantees (eventual consistency)."]}),"\n",(0,r.jsx)(n.h3,{id:"idempotency",children:"Idempotency"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Subscribers must handle duplicate events:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function handleProductCreated(event) {\n  const productId = event.AGGREGATE_ID;\n\n  // Check if already indexed\n  const exists = await elasticsearch.exists({\n    index: 'products',\n    id: productId\n  });\n\n  if (exists) {\n    console.log(`Product ${productId} already indexed. Skipping.`);\n    return;  // Idempotent - no-op on duplicate\n  }\n\n  // Index product\n  await elasticsearch.index({\n    index: 'products',\n    id: productId,\n    body: event.PAYLOAD\n  });\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"monitoring-and-operations",children:"Monitoring and Operations"}),"\n",(0,r.jsx)(n.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Monitor outbox lag:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Pending events (should be near zero)\nSELECT COUNT(*) as PENDING_COUNT\nFROM OUTBOX\nWHERE STATUS = 'PENDING';\n\n-- Failed events (requires attention)\nSELECT COUNT(*) as FAILED_COUNT\nFROM OUTBOX\nWHERE STATUS = 'FAILED';\n\n-- Oldest pending event (lag indicator)\nSELECT MIN(CREATED_AT) as OLDEST_PENDING\nFROM OUTBOX\nWHERE STATUS = 'PENDING';\n"})}),"\n",(0,r.jsx)(n.h3,{id:"retry-failed-events",children:"Retry Failed Events"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Manual retry command:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Retry failed events (reset to pending)\nUPDATE OUTBOX\nSET STATUS = 'PENDING',\n    ERROR_MESSAGE = NULL\nWHERE STATUS = 'FAILED'\n  AND RETRY_COUNT < 5;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cleanup-old-events",children:"Cleanup Old Events"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Archive or delete published events:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- Delete events older than 30 days\nDELETE FROM OUTBOX\nWHERE STATUS = 'PUBLISHED'\n  AND PUBLISHED_AT < DATE_SUB(NOW(), INTERVAL 30 DAY);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"-do",children:"\u2705 DO:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Trust outbox for event publishing:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"// \u2705 Good - CoreWrite handles event publishing\nawait createProduct(data);\n// Event automatically published via outbox\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Make subscribers idempotent:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u2705 Good - check before processing\nif (await exists(event.AGGREGATE_ID)) {\n  return;  // Already processed\n}\nawait process(event);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Monitor outbox lag:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"-- \u2705 Good - alert if lag > 1 minute\nSELECT COUNT(*) FROM OUTBOX\nWHERE STATUS = 'PENDING'\n  AND CREATED_AT < DATE_SUB(NOW(), INTERVAL 1 MINUTE);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-dont",children:"\u274c DON'T:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Don't try to publish events manually:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad - outbox handles this\nawait createProduct(data);\nawait rabbitMQ.publish('ProductCreated', data);  // Duplicate!\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Don't assume event ordering across aggregates:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad - no ordering guarantee\n// Order 1 created \u2192 Order 2 created\n// But Order 2 might be processed first\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Don't skip idempotency checks:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// \u274c Bad - duplicate processing\nasync function handleEvent(event) {\n  await process(event);  // No idempotency check!\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Outbox pattern ensures reliable event publishing"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Events persisted in OUTBOX table (same transaction)"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Background process publishes to RabbitMQ"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 At-least-once delivery guarantee"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Fanout exchange broadcasts to all subscribers"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Subscribers must be idempotent"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Event ordering within same aggregate"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Eventual consistency across microservices"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Takeaways:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Every write operation creates outbox event"}),"\n",(0,r.jsx)(n.li,{children:"Event and data persisted atomically (ACID)"}),"\n",(0,r.jsx)(n.li,{children:"Background publisher polls OUTBOX and publishes to RabbitMQ"}),"\n",(0,r.jsx)(n.li,{children:"Subscribers process events independently"}),"\n",(0,r.jsx)(n.li,{children:"Idempotency required (duplicate events possible)"}),"\n",(0,r.jsx)(n.li,{children:"Monitor OUTBOX for lag and failures"}),"\n",(0,r.jsx)(n.li,{children:"Cleanup old published events periodically"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event Flow:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Write Operation \u2192 OUTBOX (PENDING) \u2192 Publisher \u2192 RabbitMQ \u2192 Subscribers\n    \u2193                                    \u2193\nData persisted                    Event published\n(transactional)                   (eventually)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next:"})," ",(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/counter-management",children:"Counter Management \u2192"})]}),"\n",(0,r.jsx)(n.h2,{id:"related-concepts",children:"Related Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/transactions",children:"Transactions"})," - ACID guarantees"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/create-operations",children:"Create Operations"})," - Event creation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/update-operations",children:"Update Operations"})," - Update events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/delete-operations",children:"Delete Operations"})," - Delete events"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},2172:(e,n,t)=>{t.d(n,{I:()=>d,M:()=>a});var r=t(1504);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);