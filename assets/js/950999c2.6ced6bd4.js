"use strict";(self.webpackChunkq_01_docs=self.webpackChunkq_01_docs||[]).push([[1176],{4052:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var r=t(7624),a=t(2172);const s={title:"Common Use Cases",sidebar_label:"Use Cases",sidebar_position:2,description:"Real-world implementation patterns and examples"},i="Common Use Cases",o={id:"products/map.q01.io/core-api-platform-v4/best-practices/use-cases",title:"Common Use Cases",description:"Real-world implementation patterns and examples",source:"@site/docs/products/map.q01.io/core-api-platform-v4/07-best-practices/use-cases.md",sourceDirName:"products/map.q01.io/core-api-platform-v4/07-best-practices",slug:"/products/map.q01.io/core-api-platform-v4/best-practices/use-cases",permalink:"/docs/products/map.q01.io/core-api-platform-v4/best-practices/use-cases",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Common Use Cases",sidebar_label:"Use Cases",sidebar_position:2,description:"Real-world implementation patterns and examples"},sidebar:"mapSidebar",previous:{title:"Best Practices",permalink:"/docs/products/map.q01.io/core-api-platform-v4/best-practices/"},next:{title:"Anti-Patterns",permalink:"/docs/products/map.q01.io/core-api-platform-v4/best-practices/anti-patterns"}},c={},d=[{value:"Overview",id:"overview",level:2},{value:"Use Case 1: Product Catalog Management",id:"use-case-1-product-catalog-management",level:2},{value:"Scenario",id:"scenario",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Use Case 2: Order Processing Workflow",id:"use-case-2-order-processing-workflow",level:2},{value:"Scenario",id:"scenario-1",level:3},{value:"Implementation",id:"implementation-1",level:3},{value:"Use Case 3: Multi-Tenant Application",id:"use-case-3-multi-tenant-application",level:2},{value:"Scenario",id:"scenario-2",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"Use Case 4: Real-Time Dashboard",id:"use-case-4-real-time-dashboard",level:2},{value:"Scenario",id:"scenario-3",level:3},{value:"Implementation",id:"implementation-3",level:3},{value:"Use Case 5: Data Migration",id:"use-case-5-data-migration",level:2},{value:"Scenario",id:"scenario-4",level:3},{value:"Implementation",id:"implementation-4",level:3},{value:"Summary",id:"summary",level:2},{value:"Related Concepts",id:"related-concepts",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["This guide provides ",(0,r.jsx)(n.strong,{children:"production-ready code examples"})," for common Q01 Core API use cases. Each pattern includes complete implementation with error handling, performance optimization, and best practices."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Covered Use Cases:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Product Catalog Management"}),"\n",(0,r.jsx)(n.li,{children:"Order Processing Workflow"}),"\n",(0,r.jsx)(n.li,{children:"Customer Data Management"}),"\n",(0,r.jsx)(n.li,{children:"Inventory Synchronization"}),"\n",(0,r.jsx)(n.li,{children:"Multi-Tenant Application"}),"\n",(0,r.jsx)(n.li,{children:"Real-Time Dashboard"}),"\n",(0,r.jsx)(n.li,{children:"Data Migration Project"}),"\n",(0,r.jsx)(n.li,{children:"External System Integration"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"use-case-1-product-catalog-management",children:"Use Case 1: Product Catalog Management"}),"\n",(0,r.jsx)(n.h3,{id:"scenario",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"E-commerce application managing product catalog with categories, prices, and inventory."}),"\n",(0,r.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ProductCatalogService {\n  constructor(coreAPI) {\n    this.coreAPI = coreAPI;\n    this.cache = new Map();\n  }\n\n  // Get products by category with caching\n  async getProductsByCategory(categoryId, page = 1, limit = 20) {\n    const cacheKey = `category:${categoryId}:${page}:${limit}`;\n\n    // Check cache\n    if (this.cache.has(cacheKey)) {\n      const cached = this.cache.get(cacheKey);\n      if (Date.now() - cached.timestamp < 300000) { // 5 minutes\n        return cached.data;\n      }\n    }\n\n    // Fetch from API\n    const response = await this.coreAPI.get('/api/v4/core/products', {\n      params: {\n        filters: `XPRD05:eq:${categoryId},TREC:eq:N,XPRD06:eq:Y`,\n        fields: 'PRD_ID,XPRD01,XPRD02,XPRD03,XPRD04,XPRD05',\n        order_by: 'XPRD01',\n        limit: limit,\n        offset: (page - 1) * limit\n      }\n    });\n\n    // Cache result\n    this.cache.set(cacheKey, {\n      data: response.data,\n      timestamp: Date.now()\n    });\n\n    return response.data;\n  }\n\n  // Create product with validation\n  async createProduct(productData) {\n    // Validate required fields\n    const required = ['XPRD01', 'XPRD02', 'XPRD05'];\n    for (const field of required) {\n      if (!productData[field]) {\n        throw new Error(`Missing required field: ${field}`);\n      }\n    }\n\n    // Set defaults\n    productData.XPRD06 = productData.XPRD06 || 'Y'; // Active by default\n    productData.TREC = 'N'; // New record\n\n    try {\n      const response = await this.coreAPI.post('/api/v4/core/products', productData);\n\n      // Invalidate category cache\n      this.invalidateCategoryCache(productData.XPRD05);\n\n      return response.data;\n    } catch (error) {\n      console.error('Failed to create product:', error);\n      throw error;\n    }\n  }\n\n  // Update product price\n  async updatePrice(productId, newPrice) {\n    const response = await this.coreAPI.patch(`/api/v4/core/products/${productId}`, {\n      XPRD02: newPrice\n    });\n\n    // Invalidate product cache\n    this.cache.delete(`product:${productId}`);\n\n    return response.data;\n  }\n\n  // Bulk price update\n  async bulkUpdatePrices(updates) {\n    const batchSize = 100;\n    const batches = this.chunk(updates, batchSize);\n\n    for (const batch of batches) {\n      await this.coreAPI.put('/api/v4/core/products/batch', {\n        records: batch\n      });\n    }\n\n    // Clear all caches\n    this.cache.clear();\n  }\n\n  // Search products\n  async searchProducts(query, filters = {}) {\n    const response = await this.coreAPI.get('/api/v4/core/products', {\n      params: {\n        search: query,\n        filters: this.buildFilters(filters),\n        fields: 'PRD_ID,XPRD01,XPRD02,XPRD03,XPRD04',\n        limit: 50\n      }\n    });\n\n    return response.data;\n  }\n\n  buildFilters(filters) {\n    const parts = ['TREC:eq:N'];\n\n    if (filters.category) parts.push(`XPRD05:eq:${filters.category}`);\n    if (filters.active !== undefined) parts.push(`XPRD06:eq:${filters.active ? 'Y' : 'N'}`);\n    if (filters.minPrice) parts.push(`XPRD02:gte:${filters.minPrice}`);\n    if (filters.maxPrice) parts.push(`XPRD02:lte:${filters.maxPrice}`);\n\n    return parts.join(',');\n  }\n\n  invalidateCategoryCache(categoryId) {\n    for (const [key, value] of this.cache.entries()) {\n      if (key.startsWith(`category:${categoryId}:`)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  chunk(array, size) {\n    const chunks = [];\n    for (let i = 0; i < array.length; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n}\n\n// Usage\nconst catalogService = new ProductCatalogService(coreAPIClient);\n\n// Get products by category\nconst products = await catalogService.getProductsByCategory(5, 1, 20);\n\n// Create new product\nconst newProduct = await catalogService.createProduct({\n  XPRD01: 'Widget Pro 2024',\n  XPRD02: 49.99,\n  XPRD03: 'WGT-2024-001',\n  XPRD04: 'widget-pro-2024',\n  XPRD05: 5,\n  XPRD06: 'Y'\n});\n\n// Update price\nawait catalogService.updatePrice(123, 44.99);\n\n// Bulk update\nawait catalogService.bulkUpdatePrices([\n  {PRD_ID: 123, XPRD02: 44.99},\n  {PRD_ID: 124, XPRD02: 54.99},\n  {PRD_ID: 125, XPRD02: 64.99}\n]);\n\n// Search\nconst results = await catalogService.searchProducts('widget', {\n  category: 5,\n  minPrice: 20,\n  maxPrice: 100\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-case-2-order-processing-workflow",children:"Use Case 2: Order Processing Workflow"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-1",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"Handle complete order lifecycle from creation to fulfillment."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class OrderProcessingService {\n  constructor(coreAPI, eventBus) {\n    this.coreAPI = coreAPI;\n    this.eventBus = eventBus;\n  }\n\n  // Create order with line items\n  async createOrder(orderData) {\n    try {\n      // 1. Create order header\n      const order = await this.coreAPI.post('/api/v4/core/orders', {\n        XORD_CUSTOMER_ID: orderData.customerId,\n        XORD_DATE: new Date().toISOString(),\n        XORD_STATUS: 'PENDING',\n        XORD_TOTAL: orderData.total,\n        TREC: 'N'\n      });\n\n      // 2. Create order lines\n      for (const item of orderData.items) {\n        await this.coreAPI.post('/api/v4/core/order_lines', {\n          XORDLN_ORDER_ID: order.ORD_ID,\n          XORDLN_PRODUCT_ID: item.productId,\n          XORDLN_QUANTITY: item.quantity,\n          XORDLN_PRICE: item.price,\n          XORDLN_TOTAL: item.quantity * item.price,\n          TREC: 'N'\n        });\n      }\n\n      // 3. Reserve inventory\n      await this.reserveInventory(orderData.items);\n\n      // 4. Emit event\n      this.eventBus.emit('order.created', {\n        orderId: order.ORD_ID,\n        customerId: orderData.customerId,\n        total: orderData.total\n      });\n\n      return order;\n    } catch (error) {\n      console.error('Failed to create order:', error);\n      throw error;\n    }\n  }\n\n  // Update order status\n  async updateOrderStatus(orderId, newStatus) {\n    const order = await this.coreAPI.patch(`/api/v4/core/orders/${orderId}`, {\n      XORD_STATUS: newStatus,\n      XORD_UPDATED_AT: new Date().toISOString()\n    });\n\n    // Emit status change event\n    this.eventBus.emit('order.status_changed', {\n      orderId: orderId,\n      oldStatus: order.XORD_STATUS,\n      newStatus: newStatus\n    });\n\n    // Handle status-specific actions\n    switch (newStatus) {\n      case 'CONFIRMED':\n        await this.processPayment(orderId);\n        break;\n      case 'SHIPPED':\n        await this.sendShippingNotification(orderId);\n        break;\n      case 'DELIVERED':\n        await this.completeOrder(orderId);\n        break;\n      case 'CANCELLED':\n        await this.releaseInventory(orderId);\n        break;\n    }\n\n    return order;\n  }\n\n  // Get order with details\n  async getOrderDetails(orderId) {\n    // Get order header\n    const order = await this.coreAPI.get(`/api/v4/core/orders/${orderId}`, {\n      params: {\n        expand: 'XORD_CUSTOMER_ID'\n      }\n    });\n\n    // Get order lines\n    const lines = await this.coreAPI.get('/api/v4/core/order_lines', {\n      params: {\n        filters: `XORDLN_ORDER_ID:eq:${orderId}`,\n        expand: 'XORDLN_PRODUCT_ID'\n      }\n    });\n\n    return {\n      ...order.data,\n      lines: lines.data\n    };\n  }\n\n  // Reserve inventory\n  async reserveInventory(items) {\n    for (const item of items) {\n      await this.coreAPI.patch(`/api/v4/core/inventory/${item.productId}`, {\n        XINV_RESERVED: {$inc: item.quantity}\n      });\n    }\n  }\n\n  // Release inventory\n  async releaseInventory(orderId) {\n    const lines = await this.coreAPI.get('/api/v4/core/order_lines', {\n      params: {\n        filters: `XORDLN_ORDER_ID:eq:${orderId}`\n      }\n    });\n\n    for (const line of lines.data) {\n      await this.coreAPI.patch(`/api/v4/core/inventory/${line.XORDLN_PRODUCT_ID}`, {\n        XINV_RESERVED: {$inc: -line.XORDLN_QUANTITY}\n      });\n    }\n  }\n\n  async processPayment(orderId) {\n    // Payment processing logic\n    console.log(`Processing payment for order ${orderId}`);\n  }\n\n  async sendShippingNotification(orderId) {\n    // Shipping notification logic\n    console.log(`Sending shipping notification for order ${orderId}`);\n  }\n\n  async completeOrder(orderId) {\n    // Order completion logic\n    console.log(`Completing order ${orderId}`);\n  }\n}\n\n// Usage\nconst orderService = new OrderProcessingService(coreAPIClient, eventBus);\n\n// Create order\nconst order = await orderService.createOrder({\n  customerId: 456,\n  items: [\n    {productId: 123, quantity: 2, price: 29.99},\n    {productId: 124, quantity: 1, price: 49.99}\n  ],\n  total: 109.97\n});\n\n// Update status\nawait orderService.updateOrderStatus(order.ORD_ID, 'CONFIRMED');\nawait orderService.updateOrderStatus(order.ORD_ID, 'SHIPPED');\nawait orderService.updateOrderStatus(order.ORD_ID, 'DELIVERED');\n\n// Get details\nconst details = await orderService.getOrderDetails(order.ORD_ID);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-case-3-multi-tenant-application",children:"Use Case 3: Multi-Tenant Application"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-2",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"SaaS application serving multiple tenants with data isolation."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class TenantService {\n  constructor(coreAPI) {\n    this.coreAPI = coreAPI;\n  }\n\n  // Set tenant context for all requests\n  setTenantContext(tenantId, userId, peso = 3) {\n    this.context = {\n      source: tenantId,\n      peso: peso,\n      ambiente: 'P',\n      centro_dett: 'HQ',\n      modulo: 'app',\n      lingua: 'IT'\n    };\n\n    // Add interceptor to include context in all requests\n    this.coreAPI.interceptors.request.use(config => {\n      config.headers['X-Source'] = this.context.source;\n      config.headers['X-Peso'] = this.context.peso;\n      config.headers['X-Ambiente'] = this.context.ambiente;\n      config.headers['X-Centro-Dett'] = this.context.centro_dett;\n      return config;\n    });\n  }\n\n  // Get tenant-specific data\n  async getTenantData(dimension, filters = {}) {\n    // Context automatically applied via interceptor\n    const response = await this.coreAPI.get(`/api/v4/core/${dimension}`, {\n      params: {\n        filters: this.buildFilters(filters),\n        limit: 100\n      }\n    });\n\n    return response.data;\n  }\n\n  // Create tenant-specific record\n  async createTenantRecord(dimension, data) {\n    // source automatically set from context\n    const response = await this.coreAPI.post(`/api/v4/core/${dimension}`, {\n      ...data,\n      TREC: 'N'\n    });\n\n    return response.data;\n  }\n\n  // Tenant analytics\n  async getTenantMetrics() {\n    const [products, orders, customers] = await Promise.all([\n      this.getTenantData('products', {active: true}),\n      this.getTenantData('orders', {status: 'CONFIRMED'}),\n      this.getTenantData('customers', {active: true})\n    ]);\n\n    return {\n      totalProducts: products.total,\n      totalOrders: orders.total,\n      totalCustomers: customers.total,\n      activeProducts: products.data.filter(p => p.XPRD06 === 'Y').length\n    };\n  }\n\n  buildFilters(filters) {\n    const parts = ['TREC:eq:N'];\n\n    if (filters.active !== undefined) {\n      // Dimension-specific active field\n      parts.push(`XPRD06:eq:${filters.active ? 'Y' : 'N'}`);\n    }\n\n    if (filters.status) {\n      parts.push(`XORD_STATUS:eq:${filters.status}`);\n    }\n\n    return parts.join(',');\n  }\n}\n\n// Usage per tenant\nconst tenantService = new TenantService(coreAPIClient);\n\n// Tenant A session\ntenantService.setTenantContext('tenant_a', 'user_1', 3);\nconst tenantAProducts = await tenantService.getTenantData('products');\n// Only sees tenant_a products\n\n// Tenant B session\ntenantService.setTenantContext('tenant_b', 'user_2', 3);\nconst tenantBProducts = await tenantService.getTenantData('products');\n// Only sees tenant_b products (complete isolation)\n\n// Analytics\nconst metrics = await tenantService.getTenantMetrics();\nconsole.log(metrics);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-case-4-real-time-dashboard",children:"Use Case 4: Real-Time Dashboard"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-3",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"Admin dashboard with real-time metrics and updates."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class DashboardService {\n  constructor(coreAPI, websocket) {\n    this.coreAPI = coreAPI;\n    this.websocket = websocket;\n    this.metrics = new Map();\n    this.subscribers = new Set();\n  }\n\n  // Initialize dashboard\n  async initialize() {\n    // Load initial metrics\n    await this.refreshMetrics();\n\n    // Subscribe to real-time updates (OUTBOX events)\n    this.websocket.on('ProductCreated', () => this.refreshMetrics());\n    this.websocket.on('OrderCreated', () => this.refreshMetrics());\n    this.websocket.on('CustomerCreated', () => this.refreshMetrics());\n\n    // Periodic refresh (every 30 seconds)\n    setInterval(() => this.refreshMetrics(), 30000);\n  }\n\n  async refreshMetrics() {\n    try {\n      const [products, orders, revenue, customers] = await Promise.all([\n        this.getProductMetrics(),\n        this.getOrderMetrics(),\n        this.getRevenueMetrics(),\n        this.getCustomerMetrics()\n      ]);\n\n      const metrics = {\n        products,\n        orders,\n        revenue,\n        customers,\n        timestamp: Date.now()\n      };\n\n      this.metrics.set('dashboard', metrics);\n\n      // Notify subscribers\n      this.notifySubscribers(metrics);\n\n      return metrics;\n    } catch (error) {\n      console.error('Failed to refresh metrics:', error);\n      throw error;\n    }\n  }\n\n  async getProductMetrics() {\n    const response = await this.coreAPI.get('/api/v4/core/products', {\n      params: {\n        filters: 'TREC:eq:N',\n        aggregate: 'count',\n        group_by: 'XPRD05'\n      }\n    });\n\n    return {\n      total: response.total,\n      active: response.data.filter(p => p.XPRD06 === 'Y').length,\n      byCategory: response.data\n    };\n  }\n\n  async getOrderMetrics() {\n    const response = await this.coreAPI.get('/api/v4/core/orders', {\n      params: {\n        filters: 'TREC:eq:N',\n        aggregate: 'count,sum:XORD_TOTAL',\n        group_by: 'XORD_STATUS'\n      }\n    });\n\n    return {\n      total: response.total,\n      byStatus: response.data\n    };\n  }\n\n  async getRevenueMetrics() {\n    const today = new Date().toISOString().split('T')[0];\n\n    const response = await this.coreAPI.get('/api/v4/core/orders', {\n      params: {\n        filters: `TREC:eq:N,XORD_STATUS:eq:CONFIRMED,XORD_DATE:gte:${today}`,\n        aggregate: 'sum:XORD_TOTAL'\n      }\n    });\n\n    return {\n      today: response.aggregates.sum_XORD_TOTAL || 0\n    };\n  }\n\n  async getCustomerMetrics() {\n    const response = await this.coreAPI.get('/api/v4/core/customers', {\n      params: {\n        filters: 'TREC:eq:N',\n        aggregate: 'count'\n      }\n    });\n\n    return {\n      total: response.total\n    };\n  }\n\n  // Subscribe to metric updates\n  subscribe(callback) {\n    this.subscribers.add(callback);\n\n    // Return unsubscribe function\n    return () => this.subscribers.delete(callback);\n  }\n\n  notifySubscribers(metrics) {\n    for (const callback of this.subscribers) {\n      try {\n        callback(metrics);\n      } catch (error) {\n        console.error('Subscriber error:', error);\n      }\n    }\n  }\n}\n\n// Usage\nconst dashboardService = new DashboardService(coreAPIClient, websocket);\n\n// Initialize\nawait dashboardService.initialize();\n\n// Subscribe to updates\nconst unsubscribe = dashboardService.subscribe((metrics) => {\n  console.log('Dashboard updated:', metrics);\n  updateUI(metrics);\n});\n\n// Get current metrics\nconst metrics = dashboardService.metrics.get('dashboard');\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-case-5-data-migration",children:"Use Case 5: Data Migration"}),"\n",(0,r.jsx)(n.h3,{id:"scenario-4",children:"Scenario"}),"\n",(0,r.jsx)(n.p,{children:"Migrate data from legacy system to Q01 Core APIs."}),"\n",(0,r.jsx)(n.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class DataMigrationService {\n  constructor(coreAPI, legacyDB) {\n    this.coreAPI = coreAPI;\n    this.legacyDB = legacyDB;\n    this.batchSize = 100;\n  }\n\n  async migrateProducts() {\n    const stats = {\n      total: 0,\n      migrated: 0,\n      failed: 0,\n      errors: []\n    };\n\n    try {\n      // 1. Get total count\n      const countResult = await this.legacyDB.query(\n        'SELECT COUNT(*) as total FROM products'\n      );\n      stats.total = countResult[0].total;\n\n      console.log(`Migrating ${stats.total} products...`);\n\n      // 2. Process in batches\n      let offset = 0;\n      while (offset < stats.total) {\n        const batch = await this.fetchLegacyBatch(offset);\n        const transformed = this.transformProducts(batch);\n\n        try {\n          await this.coreAPI.post('/api/v4/core/products/batch', {\n            records: transformed\n          });\n\n          stats.migrated += batch.length;\n          console.log(`Progress: ${stats.migrated}/${stats.total}`);\n        } catch (error) {\n          stats.failed += batch.length;\n          stats.errors.push({\n            offset: offset,\n            count: batch.length,\n            error: error.message\n          });\n        }\n\n        offset += this.batchSize;\n      }\n\n      return stats;\n    } catch (error) {\n      console.error('Migration failed:', error);\n      throw error;\n    }\n  }\n\n  async fetchLegacyBatch(offset) {\n    return this.legacyDB.query(\n      `SELECT * FROM products LIMIT ${this.batchSize} OFFSET ${offset}`\n    );\n  }\n\n  transformProducts(legacyProducts) {\n    return legacyProducts.map(legacy => ({\n      XPRD01: legacy.name,\n      XPRD02: legacy.price,\n      XPRD03: legacy.code,\n      XPRD04: this.slugify(legacy.name),\n      XPRD05: legacy.category_id,\n      XPRD06: legacy.active ? 'Y' : 'N',\n      TREC: 'N'\n    }));\n  }\n\n  slugify(text) {\n    return text\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-|-$/g, '');\n  }\n\n  // Validation\n  async validateMigration() {\n    const [legacyCount, coreCount] = await Promise.all([\n      this.legacyDB.query('SELECT COUNT(*) as total FROM products'),\n      this.coreAPI.get('/api/v4/core/products', {params: {limit: 0}})\n    ]);\n\n    return {\n      legacy: legacyCount[0].total,\n      core: coreCount.total,\n      match: legacyCount[0].total === coreCount.total\n    };\n  }\n}\n\n// Usage\nconst migrationService = new DataMigrationService(coreAPIClient, legacyDB);\n\n// Run migration\nconst stats = await migrationService.migrateProducts();\nconsole.log(`Migrated: ${stats.migrated}/${stats.total}`);\nconsole.log(`Failed: ${stats.failed}`);\n\n// Validate\nconst validation = await migrationService.validateMigration();\nconsole.log(`Validation: ${validation.match ? 'PASS' : 'FAIL'}`);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Product catalog: Caching, bulk updates, search"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Order processing: Complete lifecycle management"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Multi-tenancy: Data isolation per tenant"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Real-time dashboard: Live metrics with WebSocket"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Data migration: Batch processing with validation"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Takeaways:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Use caching for frequently accessed data"}),"\n",(0,r.jsx)(n.li,{children:"Implement proper error handling and retry logic"}),"\n",(0,r.jsx)(n.li,{children:"Leverage batch operations for performance"}),"\n",(0,r.jsx)(n.li,{children:"Apply context correctly for multi-tenancy"}),"\n",(0,r.jsx)(n.li,{children:"Subscribe to OUTBOX events for real-time updates"}),"\n",(0,r.jsx)(n.li,{children:"Transform legacy data carefully during migration"}),"\n",(0,r.jsx)(n.li,{children:"Validate data after migration"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-concepts",children:"Related Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/api-operations/",children:"API Operations"})," - API reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/query-patterns/",children:"Query Patterns"})," - Advanced queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/write-patterns/",children:"Write Patterns"})," - CRUD operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/best-practices/performance-tips",children:"Performance Tips"})," - Optimization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/products/map.q01.io/core-api-platform-v4/best-practices",children:"Best Practices"})," - Overview"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},2172:(e,n,t)=>{t.d(n,{I:()=>o,M:()=>i});var r=t(1504);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);